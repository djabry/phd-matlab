function [wavenum, rad, tau, lblrtm_success, tmp_work_dir] = ...
    simple_matlab_lblrun(cleanup_flag, ...
    atmflag, prof, VBOUND, varargin)
% [wavenum, rad, tau, lblrtm_success, tmp_work_dir] = ...
%     simple_matlab_lblrun(cleanup_flag ...args... )
%
% Yet another wrapper for LBLRTM - this time, create a temporary working
% directory, run LBLRTM, read the radiance, transmission and wavenumber
% arrays into MATLAB variables, and then delete the working directory.
%
% This will only work for 'simple' LBLRTM runs - basically, single merged
% paths, to compute upwelling or downwelling radiance. Can be FFTscanned. 
%
% inputs:
%   cleanup_flag: required. Set to true to delete the LBLRTM working files,
%       set to false to leave them behind. Generally, delete the working 
%       files unless there are problems, then leave them behind for
%       debugging purposes.
%   ...args... - see create_tape5; any arguments to create_tape5 are
%       directly passed without modification.
%       HOWEVER, do not use CalcJacobian, ODonly, etc., as this script is
%       not general enough to deal with those cases.
%
% outputs:
%   wavenum: wavenumber (1/cm) grid from LBLRTM
%   rad: radiance array in LBLRTM units (W/cm^2/sr/cm^-1)
%   tau: transmission array (generally valued 0 - 1, can exceed this range 
%       if FFTscanned due to apodization issues).
%   wavenum, tau, rad, will vectors with the same length.
%   lblrtm_success: logical flag specifying if the LBLRTM run appeared
%       successful. This only checks for stop errors thrown by lblrtm
%       (which are not reliable indicators), or a missing or zero length
%       TAPE10, for indicators of a failed run.
%   tmp_work_dir: char array, directory name that was created. this is only
%       meaningful if cleanup_flag was false, otherwise the directory is
%       deleted at the end of the function.
%


% Create a temporary work directory in the current one. 
% Use current time, accurate to seconds, along with the user's name, 
% to make it very unlikely to collide with an existing directory.

tmp_work_dir = [getenv('USER') '_' datestr(now, 'yyyymmdd_HHMMSS')];

% This will fail because there is not write access to the file system 
% here, or the temp directory already exists (possible, but unlikely).
% Either condition should cause a stop error here, which is the desired
% action, since the user needs to fix before proceeding.

% make an extra attempt to handle a temp dir collision (happens some 
% times if there are multiple batch runs using the same temp work dir), 
% by appending _n to get another dir. Will try this up to 9 times, 
% then really abort, since in that case something strange is 
% happening that needs to be fixed.
if exist(tmp_work_dir, 'dir') > 0
    extra_dir_num = 1;
    tmp_work_dir_rt = tmp_work_dir;
    while (exist(tmp_work_dir,'dir') > 0) && (extra_dir_num < 10)
        tmp_work_dir = [tmp_work_dir_rt sprintf('_%1d',extra_dir_num)];
        extra_dir_num = extra_dir_num + 1;
    end
    % if this still didn't work, throw stop error
    if exist(tmp_work_dir, 'dir') > 0
        error(['Temporary working dir ' tmp_work_dir ' already exists, aborting'])
    end
end
system(['mkdir ' tmp_work_dir]);
cd(tmp_work_dir)

% stop error will occur here if varargin is malformed. (not this is not 
% checked anywhere inside this function)
create_tape5(atmflag, prof, VBOUND, varargin{:}, ...
    'OutputFile', 'TAPE5', 'comment', ...
    ['auto-generated by simple_matlab_lblrun. work dir: ' tmp_work_dir])

% one last chance for an error - $LBL_HOME might not be defined
lbl_home = getenv('LBL_HOME');
if isempty(lbl_home)
    error('LBL_HOME shell variable is not defined');
end
lblrtm_path = [lbl_home '/bin/lblrtm'];

% finally, link the TAPE3 file & other hitran things
link_cmd = ['ln -s ' lbl_home '/hitran/tape3.data TAPE3'];
unix(link_cmd);
link_cmd = ['ln -s ' lbl_home '/hitran/FSCDXS FSCDXS'];
unix(link_cmd);
link_cmd = ['ln -s ' lbl_home '/hitran/xs xs'];
unix(link_cmd);

% run LBLRTM
[status, result_text] = unix(lblrtm_path);

if status ~= 0
    disp('   LBLRTM encountered a stop error')
    lblrtm_success = false;
    wavenum = [];
    rad = [];
    tau = [];
    return
end

% check for non-zero size TAPE10 as evidence that LBLRTM was successful.
if exist('TAPE10', 'file');
    TAPE10_stats = dir('TAPE10');
    if TAPE10_stats.bytes == 0
        disp('   TAPE10 contained zero bytes, LBLRTM probably failed');
        lblrtm_success = false;
        wavenum = [];
        rad = [];
        tau = [];
        return
    else
        lblrtm_success = true;
    end
else
    disp('   No TAPE10 found, LBLRTM probably failed to run');
    lblrtm_success = false;
    wavenum = [];
    rad = [];
    tau = [];
    return
end
% now, the messy part - try to determine what we need to read back into
% matlab. We did not parse the inputs sent to create_tape5 - I didn't want
% to replicate that stuff - so, just look for what files are created.

% check for TAPE50 / TAPE51 (assume they both exist or both do not exist, 
% not one or the other.) Note the TAPE50 is the fftscanned radiance, so it
% will be a single panel file, which are assumed to be od (opt depth) even
% though one is tau (transmission) and one is radiance.
if exist('TAPE50', 'file') > 0
    dat = lbl_read('TAPE50',0,1);
    rad = dat.od;
    dat = lbl_read('TAPE51',0,1);
    wavenum = dat.v;
    tau = dat.od;
else
    % otherwise, grab data from TAPE12 (the monochromatic file)
    dat = lbl_read('TAPE12',0);
    wavenum = dat.v;
    rad = dat.rad;
    tau = dat.tau;
end

% now delete the working directory, if specified.
cd('..');
if cleanup_flag
    unix(['rm -fR ' tmp_work_dir]);
end
