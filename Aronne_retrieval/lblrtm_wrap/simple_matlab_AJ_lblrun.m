function [wavenum, K, lblrtm_success, tmp_work_dir] = ...
    simple_matlab_AJ_lblrun(cleanup_flag, ...
    atmflag, prof, VBOUND, varargin)
% [wavenum, K, lblrtm_success, tmp_work_dir] = ...
%     simple_matlab_AJ_lblrun(cleanup_flag ...args... )
%
% Yet another wrapper for LBLRTM - this time, create a temporary working
% directory, run LBLRTM to create Analytic Jacobians, and then read the 
% read the jacobian into MATLAB variables, and then delete the working 
% directory.
%
% This will only work for AJ LBLRTM runs, with FFT scanning.
%
% inputs:
%   cleanup_flag: required. Set to true to delete the LBLRTM working files,
%       set to false to leave them behind. Generally, delete the working 
%       files unless there are problems, then leave them behind for
%       debugging purposes.
%   ...args... - see create_tape5; any arguments to create_tape5 are
%       directly passed without modification.
%       CalcJacobian and FTSParams MUST BE INCLUDED!
%
% outputs:
%   wavenum: wavenumber (1/cm) grid from LBLRTM
%   K: jacobian, of size [Nwave, Nstate]
%       The number of derivatives depends on the value of the
%       CalcJacobian input; a value of -1 implies 2 states (surface
%       temperature and emissivity); any non-negative integer will
%       add Nlevel states. The level derivatives are read from the
%       LBLRTM output (not the layer derivatives).
%       The different derivatives are all concatenated into the
%       single K matrix; for example with 40 levels, and
%       calcJacobian equal to [-1,0,1], the resulting K will have
%       82 columns, with 1=surface temp, 2=surface emis; 3:42=temp
%       profile; 43:82 = water vapor profile.
%   lblrtm_success: logical flag specifying if the LBLRTM run appeared
%       successful. This only checks for stop errors thrown by lblrtm
%       (which are not reliable indicators), or a missing or zero length
%       TAPE10, for indicators of a failed run.
%   tmp_work_dir: char array, directory name that was created. this is only
%       meaningful if cleanup_flag was false, otherwise the directory is
%       deleted at the end of the function.
%

% pull FTSParams out of varargin - assume the varargin is properly formed,
% so the parameter names are odd numbered.
found_fts_params = false(length(varargin),1);
for q = 1:2:length(varargin);
    if ~ischar(varargin{q})
        error(['Parameter in position ' num2str(q) ' was not a string']);
    else
        found_fts_params(q) = strcmpi(varargin{q}, 'FTSPARAMS');
    end
end
fts_params_idx = find(found_fts_params);
if isempty(fts_params_idx)
    error('FTSParams not specified')
else
    % if for some reason two FTSparams are specified in the input
    % arguments, this chooses only the first of the two.
    ftsparams = varargin{fts_params_idx(1)+1};
end

% Create a temporary work directory in the current one. 
% Use current time, accurate to seconds, along with the user's name, 
% to make it very unlikely to collide with an existing directory.

tmp_work_dir = [getenv('USER') '_' datestr(now, 'yyyymmdd_HHMMSS')];

% This will fail because there is not write access to the file system 
% here, or the temp directory already exists (possible, but unlikely).
% Either condition should cause a stop error here, which is the desired
% action, since the user needs to fix before proceeding.

% make an extra attempt to handle a temp dir collision (happens some 
% times if there are multiple batch runs using the same temp work dir), 
% by appending _n to get another dir. Will try this up to 9 times, 
% then really abort, since in that case something strange is 
% happening that needs to be fixed.
if exist(tmp_work_dir, 'dir') > 0
    extra_dir_num = 1;
    tmp_work_dir_rt = tmp_work_dir;
    while (exist(tmp_work_dir,'dir') > 0) && (extra_dir_num < 10)
        tmp_work_dir = [tmp_work_dir_rt sprintf('_%1d',extra_dir_num)];
        extra_dir_num = extra_dir_num + 1;
    end
    % if this still didn't work, throw stop error
    if exist(tmp_work_dir, 'dir') > 0
        error(['Temporary working dir ' tmp_work_dir ' already exists, aborting'])
    end
end

system(['mkdir ' tmp_work_dir]);
cd(tmp_work_dir);
system('mkdir AJ');

% stop error will occur here if varargin is malformed. (not this is not 
% checked anywhere inside this function)
create_tape5(atmflag, prof, VBOUND, varargin{:}, ...
    'OutputFile', 'TAPE5', 'comment', ...
    ['auto-generated by simple_matlab_AJ_lblrun. work dir: ' tmp_work_dir])

% one last chance for an error - $LBL_HOME might not be defined
lbl_home = getenv('LBL_HOME');
if isempty(lbl_home)
    error('LBL_HOME shell variable is not defined');
end
lblrtm_path = [lbl_home '/bin/lblrtm'];

% finally, link the TAPE3 file & other hitran things
link_cmd = ['ln -s ' lbl_home '/hitran/tape3.data TAPE3'];
unix(link_cmd);
link_cmd = ['ln -s ' lbl_home '/hitran/FSCDXS FSCDXS'];
unix(link_cmd);
link_cmd = ['ln -s ' lbl_home '/hitran/xs xs'];
unix(link_cmd);

% run LBLRTM
[status, result_text] = unix(lblrtm_path);

if status ~= 0
    disp('   LBLRTM encountered a stop error')
    disp('   Returned text:')
    disp(result_text)
    lblrtm_success = false;
    wavenum = [];
    K = [];
    return
end

% check for one type of error (LBLRTM errors do not seem to be reported in
% any consistent manner, so we are forced to do these case by case checks,
% which are implemented as they become known.)

% check for a 'FATAL ERROR', of mol data set to zero. This appears to be
% "thrown" onto standard out, but does not cause a stderr condition. 
% The reported error is formatted as follows:
%  --- FATAL ERROR ---
% molecular amount for species            1
%      must be non-zero 
% for analytic jacobian #           1
%  -------------------
%
% as a crude check, we will just test for the error by looking for 
% 'FATAL ERROR' in the returned text.
if ~isempty(strfind(result_text, 'FATAL ERROR'))
    disp('   LBLRTM encountered a stop error')
    disp('   Returned text:')
    disp(result_text)
    lblrtm_success = false;
    wavenum = [];
    K = [];
    return
end

    
% check for non-zero size TAPE10 as evidence that LBLRTM was successful.
if exist('TAPE10', 'file');
    TAPE10_stats = dir('TAPE10');
    if TAPE10_stats.bytes == 0
        disp('   TAPE10 contained zero bytes, LBLRTM probably failed');
        lblrtm_success = false;
        wavenum = [];
        K = [];
        return
    else
        lblrtm_success = true;
    end
else
    disp('   No TAPE10 found, LBLRTM probably failed to run');
    lblrtm_success = false;
    wavenum = [];
    K = [];
    return
end

cd('AJ');
data_dir = pwd;
[wavenum, K] = compute_K_from_AJ(data_dir, ftsparams, 1,varargin);


%Sometimes LBLRTM rounding errors cause some regions of k to explode, set
%these to 0.
K(K>1|K<-1)=0;


% now delete the working directory, if specified.
cd('../..');
if cleanup_flag
    unix(['rm -fR ' tmp_work_dir]);
end
